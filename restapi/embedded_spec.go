// Code generated by go-swagger; DO NOT EDIT.

package restapi

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
)

var (
	// SwaggerJSON embedded version of the swagger document used at generation time
	SwaggerJSON json.RawMessage
	// FlatSwaggerJSON embedded flattened version of the swagger document used at generation time
	FlatSwaggerJSON json.RawMessage
)

func init() {
	SwaggerJSON = json.RawMessage([]byte(`{
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "schemes": [
    "http",
    "https"
  ],
  "swagger": "2.0",
  "info": {
    "description": "This API specification describes a service for attaching, mounting and preparing container images and manipulating those containers.\n\nIn general, higher level objects can either reference lower level objects (e.g. a mount referencing an attachment point) by a reference ID, \nor, they can contain the full specification of those lower objects.\n\nIf an object references another by ID, deletion of that object does not effect the underlying object.\n\nIf an object defines a lower level object, that lower level object will automatically be deleted on deletion of the higher level object.\n\nFor instance, if a container contains all of the defintions for all mount points and attachments, deletion of the container will automatically unmount\nand detach those lower objects.\n",
    "title": "Image API",
    "version": "0.2.1"
  },
  "basePath": "/imageapi/v1",
  "paths": {
    "/attach": {
      "get": {
        "description": "List attachments",
        "tags": [
          "attachments"
        ],
        "operationId": "list_attachments",
        "parameters": [
          {
            "type": "integer",
            "format": "int64",
            "description": "ID of a single attachment to query.",
            "name": "id",
            "in": "query"
          },
          {
            "enum": [
              "iscsi",
              "local",
              "loopback",
              "rbd"
            ],
            "type": "string",
            "description": "Kind of attachments to query.",
            "name": "kind",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "list all attachments",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/attach"
              }
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "description": "Create a new attachment based on attach specification",
        "tags": [
          "attachments"
        ],
        "operationId": "attach",
        "parameters": [
          {
            "name": "attach",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/attach"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "attach succeed",
            "schema": {
              "$ref": "#/definitions/attach"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "description": "Detach a specified attachment.",
        "tags": [
          "attachments"
        ],
        "parameters": [
          {
            "type": "integer",
            "format": "int64",
            "name": "id",
            "in": "query",
            "required": true
          },
          {
            "type": "boolean",
            "default": false,
            "description": "Force deletion",
            "name": "force",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Detach succeed",
            "schema": {
              "$ref": "#/definitions/attach"
            }
          },
          "default": {
            "description": "Detach failed",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/container": {
      "get": {
        "description": "Get a list of containers",
        "tags": [
          "containers"
        ],
        "operationId": "list_containers",
        "parameters": [
          {
            "type": "integer",
            "format": "int64",
            "description": "Query containers by ID",
            "name": "id",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Query containers by name",
            "name": "name",
            "in": "query"
          },
          {
            "enum": [
              "created",
              "running",
              "stopping",
              "exited",
              "dead"
            ],
            "type": "string",
            "description": "Query containers by state",
            "name": "state",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "List of containers",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/container"
              }
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "description": "Create a container",
        "tags": [
          "containers"
        ],
        "operationId": "create_container",
        "parameters": [
          {
            "name": "container",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/container"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Container creation succeed",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "description": "Delete a container defition.  \nEither ` + "`" + `id` + "`" + ` or ` + "`" + `name` + "`" + ` query parameter must be specified.\n",
        "tags": [
          "containers"
        ],
        "operationId": "delete_container",
        "parameters": [
          {
            "type": "integer",
            "format": "int64",
            "description": "Delete by ID",
            "name": "id",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Delete by Name",
            "name": "name",
            "in": "query"
          },
          {
            "type": "boolean",
            "default": false,
            "description": "Force deletion",
            "name": "force",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Container deleted",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "patch": {
        "description": "Request a (valid) state for a container. \nValid states to request include: ` + "`" + `running` + "`" + `, ` + "`" + `exited` + "`" + `, ` + "`" + `paused` + "`" + ` (paused is not yet implemented)\n\nEither a valid Name or ID must be passed as a query parameter, along with a valid state parameter.\n",
        "tags": [
          "containers"
        ],
        "operationId": "set_container_state",
        "parameters": [
          {
            "enum": [
              "running",
              "exited",
              "paused"
            ],
            "type": "string",
            "description": "Desired container state",
            "name": "state",
            "in": "query",
            "required": true
          },
          {
            "type": "integer",
            "format": "int64",
            "description": "ID of container",
            "name": "id",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Name of container",
            "name": "name",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Container state changed",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/mount": {
      "get": {
        "description": "List mounts",
        "tags": [
          "mounts"
        ],
        "operationId": "list_mounts",
        "parameters": [
          {
            "type": "integer",
            "format": "int64",
            "description": "ID of a single mount to query.",
            "name": "id",
            "in": "query"
          },
          {
            "enum": [
              "attach",
              "bind",
              "nfs",
              "overlay",
              "uri"
            ],
            "type": "string",
            "description": "Kind of mounts to query.",
            "name": "kind",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "list all mounts",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/mount"
              }
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "description": "Create a new mount by mount specification.",
        "tags": [
          "mounts"
        ],
        "operationId": "mount",
        "parameters": [
          {
            "name": "mount",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/mount"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "mount succeed",
            "schema": {
              "$ref": "#/definitions/mount"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "description": "Unmount a specified mount.  Note that mount reference IDs must be specified.",
        "tags": [
          "mounts"
        ],
        "parameters": [
          {
            "type": "integer",
            "format": "int64",
            "description": "ID of mount to delete",
            "name": "id",
            "in": "query",
            "required": true
          },
          {
            "type": "boolean",
            "default": false,
            "description": "Force deletion",
            "name": "force",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Unmount succeeded",
            "schema": {
              "$ref": "#/definitions/mount"
            }
          },
          "default": {
            "description": "Unmount failed",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "attach": {
      "description": "Generically address attachments.  Attachments are objects that ultimately provide a block device file.    \n",
      "properties": {
        "device_file": {
          "description": "The device_file is the path to the system device file.",
          "type": "string",
          "readOnly": true
        },
        "id": {
          "$ref": "#/definitions/id",
          "readOnly": true
        },
        "iscsi": {
          "$ref": "#/definitions/attach_iscsi"
        },
        "kind": {
          "description": "Kind specifies the kind of attachment.  Each kind has corresponding kind-specific options.\n\nCurrently known kinds:\n\niscsi - attach an iscsi lun\nlocal - create an attachment reference to an existing block device (specifying a non-block device will fail)\nloopback - create a loopback device referencing a file in a mount\nrbd - attach a Ceph/RBD object\n\nAll kinds may or may not be fully supported by the implementation.\n",
          "type": "string",
          "enum": [
            "iscsi",
            "local",
            "loopback",
            "rbd"
          ]
        },
        "local": {
          "$ref": "#/definitions/attach_local"
        },
        "loopback": {
          "$ref": "#/definitions/attach_loopback"
        },
        "rbd": {
          "$ref": "#/definitions/attach_rbd"
        },
        "refs": {
          "type": "integer",
          "format": "int64",
          "readOnly": true
        }
      }
    },
    "attach_iscsi": {
      "description": "` + "`" + `attach_iscsi` + "`" + ` describes an block device available as an iSCSI attachment.\nCurrently, only AuthType=None is supported.\nA target are required, and should both be in IQN format.\nHost is required and can be an IP or hostname.\nIf lun is not specified, it will default to lun0.\n",
      "type": "object",
      "required": [
        "initiator",
        "target",
        "host"
      ],
      "properties": {
        "host": {
          "description": "IP or hostname of target host",
          "type": "string"
        },
        "initiator": {
          "description": "iSCSI initiator IQN",
          "type": "string"
        },
        "lun": {
          "description": "iSCSI lun on the target to select",
          "type": "integer",
          "format": "int64",
          "default": 0
        },
        "max_comands": {
          "description": "Max oustanding iSCSI commands",
          "type": "integer",
          "format": "int64",
          "default": 128
        },
        "port": {
          "description": "Port where the target is listening (default 3260)",
          "type": "integer",
          "format": "int64",
          "default": 3260
        },
        "queue_depth": {
          "description": "Max oustanding IOs",
          "type": "integer",
          "format": "int64",
          "default": 16
        },
        "scheduler": {
          "description": "Block device scheduler",
          "type": "string",
          "default": "mq-deadline"
        },
        "target": {
          "description": "IQN of the iSCSI target",
          "type": "string"
        }
      }
    },
    "attach_local": {
      "description": "` + "`" + `attach_local` + "`" + ` describes a block device that is locally present.\nThis can be used to get a reference to a local disk, for instance.\n\nLocal only supports finding device files on the local (root) system.\nIt only takes one parameter: the path to the device file.\n",
      "type": "object",
      "required": [
        "path"
      ],
      "properties": {
        "path": {
          "description": "A unix-formatted filesystem path pointing to a block device file.",
          "type": "string"
        }
      }
    },
    "attach_loopback": {
      "description": "` + "`" + `attach_loopback` + "`" + ` describes a loopback device based on an available file.\nThe file can live either on ` + "`" + `/` + "`" + ` (\"root\") or a mount, as specified by base.\nPath specifies the path relative to the base.\n",
      "type": "object",
      "required": [
        "path",
        "base"
      ],
      "properties": {
        "base": {
          "description": "base determines the relative root for the path.  There are two options:\n` + "`" + `root` + "`" + ` means to use the current root (` + "`" + `/` + "`" + `) as the base path.\n` + "`" + `mount` + "`" + ` means to use a mount as the base path. If this is specified, ` + "`" + `mount` + "`" + ` must be specified as well.\n",
          "type": "string",
          "enum": [
            "root",
            "mount"
          ]
        },
        "mount": {
          "$ref": "#/definitions/mount"
        },
        "path": {
          "description": "A unix-formatted filesystem path with ` + "`" + `/` + "`" + ` relative to the respective base.",
          "type": "string"
        },
        "readPartitions": {
          "description": "Should the partition table on the looback device be read?\nAddressing sub-partitions is not yet supported.\n",
          "type": "boolean",
          "default": false
        }
      }
    },
    "attach_rbd": {
      "description": "attach_rbd describes an RBD map.  To successfully map, at least one monitor, pool and image must be specified.\nAdditionally, you will need options.name and options.secret specified.\n",
      "type": "object",
      "required": [
        "monitors",
        "pool",
        "image"
      ],
      "properties": {
        "device_id": {
          "description": "The dev_id is the device ID in the rbd subsystem.",
          "type": "integer",
          "format": "int64",
          "readOnly": true
        },
        "image": {
          "type": "string",
          "minLength": 1
        },
        "monitors": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "ipv4",
            "pattern": "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$"
          }
        },
        "options": {
          "$ref": "#/definitions/rbd_options"
        },
        "pool": {
          "type": "string",
          "minLength": 1
        },
        "snapshot": {
          "type": "string"
        }
      }
    },
    "container": {
      "description": "The ` + "`" + `container` + "`" + ` option describes a minimally namespaced container.\n\nA container is identified by a service-provided unique numeric ` + "`" + `pid` + "`" + `.\n\nOptionally, a container can be provided with a ` + "`" + `name` + "`" + `.  The name must\nbe unique.  Containers can be referenced by ` + "`" + `name` + "`" + ` if provided.\n",
      "type": "object",
      "required": [
        "mount",
        "command"
      ],
      "properties": {
        "command": {
          "type": "string"
        },
        "hooks": {
          "$ref": "#/definitions/container_script_hooks"
        },
        "id": {
          "$ref": "#/definitions/id"
        },
        "logfile": {
          "type": "string",
          "readOnly": true
        },
        "mount": {
          "$ref": "#/definitions/mount"
        },
        "name": {
          "description": "name is an optional identifier for the container.  Name must be unique.",
          "$ref": "#/definitions/name"
        },
        "namespaces": {
          "description": "A list of Linux namespaces to use.\n\nNote: This is currently unused.  All containers currently get ` + "`" + `mnt` + "`" + ` and ` + "`" + `pid` + "`" + `.\n      It's here as a placeholder for future use.\n",
          "type": "array",
          "items": {
            "$ref": "#/definitions/container_namespace"
          }
        },
        "refs": {
          "type": "integer",
          "format": "int64",
          "readOnly": true
        },
        "state": {
          "description": "When read, this contains the current container state. On creation, this requests the initial state (valid options: ` + "`" + `created` + "`" + ` or ` + "`" + `running` + "`" + `). The default is ` + "`" + `created` + "`" + `.\n",
          "$ref": "#/definitions/container_state"
        },
        "systemd": {
          "description": "When ` + "`" + `systemd` + "`" + ` is set to ` + "`" + `true` + "`" + `, we will assume that this container will run ` + "`" + `systemd` + "`" + `, and perform the necessary magic dance to make systemd run inside of the container. The default is ` + "`" + `false` + "`" + `.\n",
          "type": "boolean"
        }
      }
    },
    "container_namespace": {
      "description": "Linux namespace",
      "type": "string",
      "enum": [
        "cgroup",
        "ipc",
        "net",
        "mnt",
        "pid",
        "time",
        "user",
        "uts"
      ]
    },
    "container_script": {
      "description": "A ` + "`" + `uinit` + "`" + ` style script to be executed on container load/unload.\n\nScripts can be passed in several ways, as specified by ` + "`" + `encoding` + "`" + `:\n- ` + "`" + `file` + "`" + ` : ` + "`" + `script` + "`" + ` must be a path to a valid file on the root filesystem.\n- ` + "`" + `container_file` + "`" + ` : ` + "`" + `script` + "`" + ` must be a path to a valid file in the contianer filesystem.\n- ` + "`" + `plain` + "`" + ` : multi-line script string.\n- ` + "`" + `base64` + "`" + ` : base64 encoded script string.\n- ` + "`" + `gzip` + "`" + ` : gzip + base64 encoded script string.\n- ` + "`" + `bzip2` + "`" + ` : bzip2 + base64 encoded script string.\n",
      "type": "object",
      "properties": {
        "encoding": {
          "description": "The type of script specification contained in ` + "`" + `script` + "`" + `",
          "type": "string",
          "enum": [
            "file",
            "container_file",
            "plain",
            "base64",
            "gzip",
            "bzip2"
          ]
        },
        "last_error": {
          "description": "The last error message reported by this script",
          "type": "string",
          "readOnly": true
        },
        "must": {
          "description": "Any script failure is considered fatal",
          "type": "boolean",
          "default": false
        },
        "script": {
          "description": "String either containing the script, or a script file location",
          "type": "string"
        },
        "success": {
          "description": "Was the last run of this script successful",
          "type": "boolean",
          "readOnly": true
        }
      }
    },
    "container_script_hook": {
      "description": "Describes a container script hook point with execution controls.\n\nScripts will be executed in array order after any default scripts.\n",
      "type": "object",
      "properties": {
        "disable_defaults": {
          "description": "Disable default script hooks.",
          "type": "boolean",
          "default": false
        },
        "scripts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/container_script"
          }
        }
      }
    },
    "container_script_hooks": {
      "description": "Container script execution hooks.\n\nWe currently provide 4 hook points:\n1. ` + "`" + `create` + "`" + ` is executed on container creation (root namespaces).\n2. ` + "`" + `init` + "`" + ` is executed in the container namespaces before the provided ` + "`" + `init` + "`" + ` is called (container namespaces). \n3. ` + "`" + `exit` + "`" + ` is executed on container exit (root namespaces).\n4. ` + "`" + `delete` + "`" + ` is executed on container deletion (root namespaces).\n",
      "type": "object",
      "properties": {
        "create": {
          "$ref": "#/definitions/container_script_hook"
        },
        "delete": {
          "$ref": "#/definitions/container_script_hook"
        },
        "exit": {
          "$ref": "#/definitions/container_script_hook"
        },
        "init": {
          "$ref": "#/definitions/container_script_hook"
        }
      }
    },
    "container_state": {
      "description": "Valid container states",
      "type": "string",
      "enum": [
        "created",
        "running",
        "stopping",
        "exited",
        "dead"
      ]
    },
    "error": {
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "code": {
          "type": "integer",
          "format": "int64"
        },
        "message": {
          "type": "string"
        }
      }
    },
    "id": {
      "description": "An ID is a unique numeric ID that references an object.  \nIDs are not necessarily unique across object types.\nIDs are generall readOnly and generated internally.\n",
      "type": "integer",
      "format": "int64"
    },
    "mount": {
      "description": "Generically address mounts by kind and ID or definition\nEither an ` + "`" + `mount_id` + "`" + ` or a mount definition must be supplied.\nIf both are supplied, the mount definition will be ignored.\nIf ` + "`" + `mount_id` + "`" + ` is specified, then the kind/id will be used to reference that mount.\nIf no ` + "`" + `mount_id` + "`" + ` is supplied a defition of type ` + "`" + `kind` + "`" + ` must be present.\n",
      "type": "object",
      "properties": {
        "attach": {
          "$ref": "#/definitions/mount_attach"
        },
        "bind": {
          "$ref": "#/definitions/mount_bind"
        },
        "id": {
          "$ref": "#/definitions/id"
        },
        "kind": {
          "description": "Kind specifies the kind of mount.  Each kind has corresponding kind-specific options.\n\nCurrently known kinds:\n\nattach - mount a device specified by an attachment.\nbind - bind mount a local directory\nnfs - mount an NFS filesystem\noverlay - overlay mount over an existing mount\nuri - download a file from a URI and extract it into a ramdisk mount\n\nAll kinds may or may not be fully supported by the implementation.\n",
          "type": "string",
          "enum": [
            "attach",
            "bind",
            "nfs",
            "overlay",
            "uri"
          ]
        },
        "mountpoint": {
          "type": "string",
          "readOnly": true
        },
        "nfs": {
          "$ref": "#/definitions/mount_nfs"
        },
        "overlay": {
          "$ref": "#/definitions/mount_overlay"
        },
        "refs": {
          "type": "integer",
          "format": "int64",
          "readOnly": true
        }
      }
    },
    "mount_attach": {
      "description": "` + "`" + `mount_attach` + "`" + ` describes an attach mount.  This must have at least attach ID associated with it, \nand a provided filesystem type.\n\nEither ` + "`" + `attach_id` + "`" + ` or ` + "`" + `attach` + "`" + ` must be specified.  If both are specified, ` + "`" + `attach` + "`" + ` will be ignored.\n\nIf ` + "`" + `attach` + "`" + ` is specified and ` + "`" + `attach_id` + "`" + ` is omitted, the specified attach will first be attached, and will be\ndetached on deletion.\n",
      "required": [
        "fs_type",
        "attach"
      ],
      "properties": {
        "attach": {
          "$ref": "#/definitions/attach"
        },
        "fs_type": {
          "type": "string"
        },
        "mount_options": {
          "description": "these mount options will be passed to the mount syscall. Supported options depend on filesystem type.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "mount_bind": {
      "description": "` + "`" + `mount_bind` + "`" + ` describes a local bind mount. \nBind mounts can be relative to another mount, or to /, allowing a way to access local data.\n",
      "type": "object",
      "required": [
        "path",
        "base"
      ],
      "properties": {
        "base": {
          "description": "base determines the relative root for the path.  There are two options:\n` + "`" + `root` + "`" + ` means to use the current root (` + "`" + `/` + "`" + `) as the base path.\n` + "`" + `mount` + "`" + ` means to use a mount as the base path. If this is specified, ` + "`" + `mount` + "`" + ` must be specified as well.\n",
          "type": "string",
          "enum": [
            "root",
            "mount"
          ]
        },
        "mount": {
          "$ref": "#/definitions/mount"
        },
        "path": {
          "description": "A unix-formatted filesystem path with ` + "`" + `/` + "`" + ` relative to the respective base.",
          "type": "string"
        },
        "recursive": {
          "description": "perform a recursive bind mount",
          "type": "boolean",
          "default": false
        },
        "ro": {
          "description": "mount read-only",
          "type": "boolean",
          "default": false
        }
      }
    },
    "mount_nfs": {
      "description": "` + "`" + `mount_nfs` + "`" + ` describes an NFS mount.\n",
      "type": "object",
      "required": [
        "host",
        "path"
      ],
      "properties": {
        "host": {
          "description": "IP or hostname for remote NFS mount",
          "type": "string"
        },
        "options": {
          "description": "Options as specified in nfs(5).  General mount options won't work here.\naddr= and clientaddr= will be filled out automatically based on host.\nvers= will be filled by version\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "path": {
          "description": "The remote path for the NFS mount",
          "type": "string"
        },
        "ro": {
          "description": "mount read-only",
          "type": "boolean",
          "default": false
        },
        "version": {
          "description": "NFS version",
          "type": "string",
          "default": "4.2"
        }
      }
    },
    "mount_overlay": {
      "description": "` + "`" + `mount_overlay` + "`" + ` describes an Overlayfs mount.  All mount points must be RBD ID's.\nAt very least, ` + "`" + `lower` + "`" + ` must be specified.  If ` + "`" + `upper` + "`" + ` length is zero, no ` + "`" + `upper` + "`" + `\nmounts will be used.  ` + "`" + `workdir` + "`" + ` will be assigned automatically.\n\nIf the mounts specified in ` + "`" + `lower` + "`" + ` are specifications and not ID references, they\nwill be recursively mounted/attached.\n\nOverlay mounts are identified by their uppermost ` + "`" + `lower` + "`" + ` ID.\n",
      "type": "object",
      "required": [
        "lower"
      ],
      "properties": {
        "lower": {
          "description": "This is an array of mount specifications to be used (in order) as lower mounts for the overlay.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/mount"
          }
        },
        "upperdir": {
          "description": "currently, upperdir is always a directory in mountDir",
          "type": "string",
          "readOnly": true
        },
        "workdir": {
          "type": "string",
          "readOnly": true
        }
      }
    },
    "name": {
      "description": "A name is a unique, user-provided identifier for an object.\n\nA name must consist of numbers, letters, and the symbols in the set { ` + "`" + `.` + "`" + `, ` + "`" + `-` + "`" + `, ` + "`" + `_` + "`" + `}.\n",
      "type": "string",
      "pattern": "^[A-Za-z0-1.\\-_]*$"
    },
    "rbd_options": {
      "type": "object",
      "properties": {
        "abort_on_full": {
          "type": "boolean"
        },
        "alloc_size": {
          "type": "integer"
        },
        "ceph_requires_signatures": {
          "type": "boolean"
        },
        "cephx_sign_messages": {
          "type": "boolean"
        },
        "crc": {
          "type": "boolean"
        },
        "exclusive": {
          "type": "boolean"
        },
        "force": {
          "type": "boolean"
        },
        "fsid": {
          "type": "string"
        },
        "ip": {
          "type": "string",
          "format": "ipv4",
          "pattern": "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$"
        },
        "lock_on_read": {
          "type": "boolean"
        },
        "lock_timeout": {
          "type": "integer",
          "format": "int64"
        },
        "mount_timeout": {
          "type": "integer"
        },
        "name": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "noceph_requires_signatures": {
          "type": "boolean"
        },
        "nocephx_sign_messages": {
          "type": "boolean"
        },
        "nocrc": {
          "type": "boolean"
        },
        "noshare": {
          "type": "boolean"
        },
        "notcp_nodelay": {
          "type": "boolean"
        },
        "notrim": {
          "type": "boolean"
        },
        "osd_idle_ttl": {
          "type": "integer"
        },
        "osdkeepalive": {
          "type": "integer"
        },
        "queue_depth": {
          "type": "integer"
        },
        "ro": {
          "type": "boolean"
        },
        "rw": {
          "type": "boolean"
        },
        "secret": {
          "type": "string"
        },
        "share": {
          "type": "boolean"
        },
        "tcp_nodelay": {
          "type": "boolean"
        }
      }
    }
  }
}`))
	FlatSwaggerJSON = json.RawMessage([]byte(`{
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "schemes": [
    "http",
    "https"
  ],
  "swagger": "2.0",
  "info": {
    "description": "This API specification describes a service for attaching, mounting and preparing container images and manipulating those containers.\n\nIn general, higher level objects can either reference lower level objects (e.g. a mount referencing an attachment point) by a reference ID, \nor, they can contain the full specification of those lower objects.\n\nIf an object references another by ID, deletion of that object does not effect the underlying object.\n\nIf an object defines a lower level object, that lower level object will automatically be deleted on deletion of the higher level object.\n\nFor instance, if a container contains all of the defintions for all mount points and attachments, deletion of the container will automatically unmount\nand detach those lower objects.\n",
    "title": "Image API",
    "version": "0.2.1"
  },
  "basePath": "/imageapi/v1",
  "paths": {
    "/attach": {
      "get": {
        "description": "List attachments",
        "tags": [
          "attachments"
        ],
        "operationId": "list_attachments",
        "parameters": [
          {
            "type": "integer",
            "format": "int64",
            "description": "ID of a single attachment to query.",
            "name": "id",
            "in": "query"
          },
          {
            "enum": [
              "iscsi",
              "local",
              "loopback",
              "rbd"
            ],
            "type": "string",
            "description": "Kind of attachments to query.",
            "name": "kind",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "list all attachments",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/attach"
              }
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "description": "Create a new attachment based on attach specification",
        "tags": [
          "attachments"
        ],
        "operationId": "attach",
        "parameters": [
          {
            "name": "attach",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/attach"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "attach succeed",
            "schema": {
              "$ref": "#/definitions/attach"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "description": "Detach a specified attachment.",
        "tags": [
          "attachments"
        ],
        "parameters": [
          {
            "type": "integer",
            "format": "int64",
            "name": "id",
            "in": "query",
            "required": true
          },
          {
            "type": "boolean",
            "default": false,
            "description": "Force deletion",
            "name": "force",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Detach succeed",
            "schema": {
              "$ref": "#/definitions/attach"
            }
          },
          "default": {
            "description": "Detach failed",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/container": {
      "get": {
        "description": "Get a list of containers",
        "tags": [
          "containers"
        ],
        "operationId": "list_containers",
        "parameters": [
          {
            "type": "integer",
            "format": "int64",
            "description": "Query containers by ID",
            "name": "id",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Query containers by name",
            "name": "name",
            "in": "query"
          },
          {
            "enum": [
              "created",
              "running",
              "stopping",
              "exited",
              "dead"
            ],
            "type": "string",
            "description": "Query containers by state",
            "name": "state",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "List of containers",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/container"
              }
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "description": "Create a container",
        "tags": [
          "containers"
        ],
        "operationId": "create_container",
        "parameters": [
          {
            "name": "container",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/container"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Container creation succeed",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "description": "Delete a container defition.  \nEither ` + "`" + `id` + "`" + ` or ` + "`" + `name` + "`" + ` query parameter must be specified.\n",
        "tags": [
          "containers"
        ],
        "operationId": "delete_container",
        "parameters": [
          {
            "type": "integer",
            "format": "int64",
            "description": "Delete by ID",
            "name": "id",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Delete by Name",
            "name": "name",
            "in": "query"
          },
          {
            "type": "boolean",
            "default": false,
            "description": "Force deletion",
            "name": "force",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Container deleted",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "patch": {
        "description": "Request a (valid) state for a container. \nValid states to request include: ` + "`" + `running` + "`" + `, ` + "`" + `exited` + "`" + `, ` + "`" + `paused` + "`" + ` (paused is not yet implemented)\n\nEither a valid Name or ID must be passed as a query parameter, along with a valid state parameter.\n",
        "tags": [
          "containers"
        ],
        "operationId": "set_container_state",
        "parameters": [
          {
            "enum": [
              "running",
              "exited",
              "paused"
            ],
            "type": "string",
            "description": "Desired container state",
            "name": "state",
            "in": "query",
            "required": true
          },
          {
            "type": "integer",
            "format": "int64",
            "description": "ID of container",
            "name": "id",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Name of container",
            "name": "name",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Container state changed",
            "schema": {
              "$ref": "#/definitions/container"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/mount": {
      "get": {
        "description": "List mounts",
        "tags": [
          "mounts"
        ],
        "operationId": "list_mounts",
        "parameters": [
          {
            "type": "integer",
            "format": "int64",
            "description": "ID of a single mount to query.",
            "name": "id",
            "in": "query"
          },
          {
            "enum": [
              "attach",
              "bind",
              "nfs",
              "overlay",
              "uri"
            ],
            "type": "string",
            "description": "Kind of mounts to query.",
            "name": "kind",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "list all mounts",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/mount"
              }
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "post": {
        "description": "Create a new mount by mount specification.",
        "tags": [
          "mounts"
        ],
        "operationId": "mount",
        "parameters": [
          {
            "name": "mount",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/mount"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "mount succeed",
            "schema": {
              "$ref": "#/definitions/mount"
            }
          },
          "default": {
            "description": "error",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      },
      "delete": {
        "description": "Unmount a specified mount.  Note that mount reference IDs must be specified.",
        "tags": [
          "mounts"
        ],
        "parameters": [
          {
            "type": "integer",
            "format": "int64",
            "description": "ID of mount to delete",
            "name": "id",
            "in": "query",
            "required": true
          },
          {
            "type": "boolean",
            "default": false,
            "description": "Force deletion",
            "name": "force",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Unmount succeeded",
            "schema": {
              "$ref": "#/definitions/mount"
            }
          },
          "default": {
            "description": "Unmount failed",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "attach": {
      "description": "Generically address attachments.  Attachments are objects that ultimately provide a block device file.    \n",
      "properties": {
        "device_file": {
          "description": "The device_file is the path to the system device file.",
          "type": "string",
          "readOnly": true
        },
        "id": {
          "$ref": "#/definitions/id",
          "readOnly": true
        },
        "iscsi": {
          "$ref": "#/definitions/attach_iscsi"
        },
        "kind": {
          "description": "Kind specifies the kind of attachment.  Each kind has corresponding kind-specific options.\n\nCurrently known kinds:\n\niscsi - attach an iscsi lun\nlocal - create an attachment reference to an existing block device (specifying a non-block device will fail)\nloopback - create a loopback device referencing a file in a mount\nrbd - attach a Ceph/RBD object\n\nAll kinds may or may not be fully supported by the implementation.\n",
          "type": "string",
          "enum": [
            "iscsi",
            "local",
            "loopback",
            "rbd"
          ]
        },
        "local": {
          "$ref": "#/definitions/attach_local"
        },
        "loopback": {
          "$ref": "#/definitions/attach_loopback"
        },
        "rbd": {
          "$ref": "#/definitions/attach_rbd"
        },
        "refs": {
          "type": "integer",
          "format": "int64",
          "readOnly": true
        }
      }
    },
    "attach_iscsi": {
      "description": "` + "`" + `attach_iscsi` + "`" + ` describes an block device available as an iSCSI attachment.\nCurrently, only AuthType=None is supported.\nA target are required, and should both be in IQN format.\nHost is required and can be an IP or hostname.\nIf lun is not specified, it will default to lun0.\n",
      "type": "object",
      "required": [
        "initiator",
        "target",
        "host"
      ],
      "properties": {
        "host": {
          "description": "IP or hostname of target host",
          "type": "string"
        },
        "initiator": {
          "description": "iSCSI initiator IQN",
          "type": "string"
        },
        "lun": {
          "description": "iSCSI lun on the target to select",
          "type": "integer",
          "format": "int64",
          "default": 0
        },
        "max_comands": {
          "description": "Max oustanding iSCSI commands",
          "type": "integer",
          "format": "int64",
          "default": 128
        },
        "port": {
          "description": "Port where the target is listening (default 3260)",
          "type": "integer",
          "format": "int64",
          "default": 3260
        },
        "queue_depth": {
          "description": "Max oustanding IOs",
          "type": "integer",
          "format": "int64",
          "default": 16
        },
        "scheduler": {
          "description": "Block device scheduler",
          "type": "string",
          "default": "mq-deadline"
        },
        "target": {
          "description": "IQN of the iSCSI target",
          "type": "string"
        }
      }
    },
    "attach_local": {
      "description": "` + "`" + `attach_local` + "`" + ` describes a block device that is locally present.\nThis can be used to get a reference to a local disk, for instance.\n\nLocal only supports finding device files on the local (root) system.\nIt only takes one parameter: the path to the device file.\n",
      "type": "object",
      "required": [
        "path"
      ],
      "properties": {
        "path": {
          "description": "A unix-formatted filesystem path pointing to a block device file.",
          "type": "string"
        }
      }
    },
    "attach_loopback": {
      "description": "` + "`" + `attach_loopback` + "`" + ` describes a loopback device based on an available file.\nThe file can live either on ` + "`" + `/` + "`" + ` (\"root\") or a mount, as specified by base.\nPath specifies the path relative to the base.\n",
      "type": "object",
      "required": [
        "path",
        "base"
      ],
      "properties": {
        "base": {
          "description": "base determines the relative root for the path.  There are two options:\n` + "`" + `root` + "`" + ` means to use the current root (` + "`" + `/` + "`" + `) as the base path.\n` + "`" + `mount` + "`" + ` means to use a mount as the base path. If this is specified, ` + "`" + `mount` + "`" + ` must be specified as well.\n",
          "type": "string",
          "enum": [
            "root",
            "mount"
          ]
        },
        "mount": {
          "$ref": "#/definitions/mount"
        },
        "path": {
          "description": "A unix-formatted filesystem path with ` + "`" + `/` + "`" + ` relative to the respective base.",
          "type": "string"
        },
        "readPartitions": {
          "description": "Should the partition table on the looback device be read?\nAddressing sub-partitions is not yet supported.\n",
          "type": "boolean",
          "default": false
        }
      }
    },
    "attach_rbd": {
      "description": "attach_rbd describes an RBD map.  To successfully map, at least one monitor, pool and image must be specified.\nAdditionally, you will need options.name and options.secret specified.\n",
      "type": "object",
      "required": [
        "monitors",
        "pool",
        "image"
      ],
      "properties": {
        "device_id": {
          "description": "The dev_id is the device ID in the rbd subsystem.",
          "type": "integer",
          "format": "int64",
          "readOnly": true
        },
        "image": {
          "type": "string",
          "minLength": 1
        },
        "monitors": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "ipv4",
            "pattern": "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$"
          }
        },
        "options": {
          "$ref": "#/definitions/rbd_options"
        },
        "pool": {
          "type": "string",
          "minLength": 1
        },
        "snapshot": {
          "type": "string"
        }
      }
    },
    "container": {
      "description": "The ` + "`" + `container` + "`" + ` option describes a minimally namespaced container.\n\nA container is identified by a service-provided unique numeric ` + "`" + `pid` + "`" + `.\n\nOptionally, a container can be provided with a ` + "`" + `name` + "`" + `.  The name must\nbe unique.  Containers can be referenced by ` + "`" + `name` + "`" + ` if provided.\n",
      "type": "object",
      "required": [
        "mount",
        "command"
      ],
      "properties": {
        "command": {
          "type": "string"
        },
        "hooks": {
          "$ref": "#/definitions/container_script_hooks"
        },
        "id": {
          "$ref": "#/definitions/id"
        },
        "logfile": {
          "type": "string",
          "readOnly": true
        },
        "mount": {
          "$ref": "#/definitions/mount"
        },
        "name": {
          "description": "name is an optional identifier for the container.  Name must be unique.",
          "$ref": "#/definitions/name"
        },
        "namespaces": {
          "description": "A list of Linux namespaces to use.\n\nNote: This is currently unused.  All containers currently get ` + "`" + `mnt` + "`" + ` and ` + "`" + `pid` + "`" + `.\n      It's here as a placeholder for future use.\n",
          "type": "array",
          "items": {
            "$ref": "#/definitions/container_namespace"
          }
        },
        "refs": {
          "type": "integer",
          "format": "int64",
          "readOnly": true
        },
        "state": {
          "description": "When read, this contains the current container state. On creation, this requests the initial state (valid options: ` + "`" + `created` + "`" + ` or ` + "`" + `running` + "`" + `). The default is ` + "`" + `created` + "`" + `.\n",
          "$ref": "#/definitions/container_state"
        },
        "systemd": {
          "description": "When ` + "`" + `systemd` + "`" + ` is set to ` + "`" + `true` + "`" + `, we will assume that this container will run ` + "`" + `systemd` + "`" + `, and perform the necessary magic dance to make systemd run inside of the container. The default is ` + "`" + `false` + "`" + `.\n",
          "type": "boolean"
        }
      }
    },
    "container_namespace": {
      "description": "Linux namespace",
      "type": "string",
      "enum": [
        "cgroup",
        "ipc",
        "net",
        "mnt",
        "pid",
        "time",
        "user",
        "uts"
      ]
    },
    "container_script": {
      "description": "A ` + "`" + `uinit` + "`" + ` style script to be executed on container load/unload.\n\nScripts can be passed in several ways, as specified by ` + "`" + `encoding` + "`" + `:\n- ` + "`" + `file` + "`" + ` : ` + "`" + `script` + "`" + ` must be a path to a valid file on the root filesystem.\n- ` + "`" + `container_file` + "`" + ` : ` + "`" + `script` + "`" + ` must be a path to a valid file in the contianer filesystem.\n- ` + "`" + `plain` + "`" + ` : multi-line script string.\n- ` + "`" + `base64` + "`" + ` : base64 encoded script string.\n- ` + "`" + `gzip` + "`" + ` : gzip + base64 encoded script string.\n- ` + "`" + `bzip2` + "`" + ` : bzip2 + base64 encoded script string.\n",
      "type": "object",
      "properties": {
        "encoding": {
          "description": "The type of script specification contained in ` + "`" + `script` + "`" + `",
          "type": "string",
          "enum": [
            "file",
            "container_file",
            "plain",
            "base64",
            "gzip",
            "bzip2"
          ]
        },
        "last_error": {
          "description": "The last error message reported by this script",
          "type": "string",
          "readOnly": true
        },
        "must": {
          "description": "Any script failure is considered fatal",
          "type": "boolean",
          "default": false
        },
        "script": {
          "description": "String either containing the script, or a script file location",
          "type": "string"
        },
        "success": {
          "description": "Was the last run of this script successful",
          "type": "boolean",
          "readOnly": true
        }
      }
    },
    "container_script_hook": {
      "description": "Describes a container script hook point with execution controls.\n\nScripts will be executed in array order after any default scripts.\n",
      "type": "object",
      "properties": {
        "disable_defaults": {
          "description": "Disable default script hooks.",
          "type": "boolean",
          "default": false
        },
        "scripts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/container_script"
          }
        }
      }
    },
    "container_script_hooks": {
      "description": "Container script execution hooks.\n\nWe currently provide 4 hook points:\n1. ` + "`" + `create` + "`" + ` is executed on container creation (root namespaces).\n2. ` + "`" + `init` + "`" + ` is executed in the container namespaces before the provided ` + "`" + `init` + "`" + ` is called (container namespaces). \n3. ` + "`" + `exit` + "`" + ` is executed on container exit (root namespaces).\n4. ` + "`" + `delete` + "`" + ` is executed on container deletion (root namespaces).\n",
      "type": "object",
      "properties": {
        "create": {
          "$ref": "#/definitions/container_script_hook"
        },
        "delete": {
          "$ref": "#/definitions/container_script_hook"
        },
        "exit": {
          "$ref": "#/definitions/container_script_hook"
        },
        "init": {
          "$ref": "#/definitions/container_script_hook"
        }
      }
    },
    "container_state": {
      "description": "Valid container states",
      "type": "string",
      "enum": [
        "created",
        "running",
        "stopping",
        "exited",
        "dead"
      ]
    },
    "error": {
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "code": {
          "type": "integer",
          "format": "int64"
        },
        "message": {
          "type": "string"
        }
      }
    },
    "id": {
      "description": "An ID is a unique numeric ID that references an object.  \nIDs are not necessarily unique across object types.\nIDs are generall readOnly and generated internally.\n",
      "type": "integer",
      "format": "int64"
    },
    "mount": {
      "description": "Generically address mounts by kind and ID or definition\nEither an ` + "`" + `mount_id` + "`" + ` or a mount definition must be supplied.\nIf both are supplied, the mount definition will be ignored.\nIf ` + "`" + `mount_id` + "`" + ` is specified, then the kind/id will be used to reference that mount.\nIf no ` + "`" + `mount_id` + "`" + ` is supplied a defition of type ` + "`" + `kind` + "`" + ` must be present.\n",
      "type": "object",
      "properties": {
        "attach": {
          "$ref": "#/definitions/mount_attach"
        },
        "bind": {
          "$ref": "#/definitions/mount_bind"
        },
        "id": {
          "$ref": "#/definitions/id"
        },
        "kind": {
          "description": "Kind specifies the kind of mount.  Each kind has corresponding kind-specific options.\n\nCurrently known kinds:\n\nattach - mount a device specified by an attachment.\nbind - bind mount a local directory\nnfs - mount an NFS filesystem\noverlay - overlay mount over an existing mount\nuri - download a file from a URI and extract it into a ramdisk mount\n\nAll kinds may or may not be fully supported by the implementation.\n",
          "type": "string",
          "enum": [
            "attach",
            "bind",
            "nfs",
            "overlay",
            "uri"
          ]
        },
        "mountpoint": {
          "type": "string",
          "readOnly": true
        },
        "nfs": {
          "$ref": "#/definitions/mount_nfs"
        },
        "overlay": {
          "$ref": "#/definitions/mount_overlay"
        },
        "refs": {
          "type": "integer",
          "format": "int64",
          "readOnly": true
        }
      }
    },
    "mount_attach": {
      "description": "` + "`" + `mount_attach` + "`" + ` describes an attach mount.  This must have at least attach ID associated with it, \nand a provided filesystem type.\n\nEither ` + "`" + `attach_id` + "`" + ` or ` + "`" + `attach` + "`" + ` must be specified.  If both are specified, ` + "`" + `attach` + "`" + ` will be ignored.\n\nIf ` + "`" + `attach` + "`" + ` is specified and ` + "`" + `attach_id` + "`" + ` is omitted, the specified attach will first be attached, and will be\ndetached on deletion.\n",
      "required": [
        "fs_type",
        "attach"
      ],
      "properties": {
        "attach": {
          "$ref": "#/definitions/attach"
        },
        "fs_type": {
          "type": "string"
        },
        "mount_options": {
          "description": "these mount options will be passed to the mount syscall. Supported options depend on filesystem type.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "mount_bind": {
      "description": "` + "`" + `mount_bind` + "`" + ` describes a local bind mount. \nBind mounts can be relative to another mount, or to /, allowing a way to access local data.\n",
      "type": "object",
      "required": [
        "path",
        "base"
      ],
      "properties": {
        "base": {
          "description": "base determines the relative root for the path.  There are two options:\n` + "`" + `root` + "`" + ` means to use the current root (` + "`" + `/` + "`" + `) as the base path.\n` + "`" + `mount` + "`" + ` means to use a mount as the base path. If this is specified, ` + "`" + `mount` + "`" + ` must be specified as well.\n",
          "type": "string",
          "enum": [
            "root",
            "mount"
          ]
        },
        "mount": {
          "$ref": "#/definitions/mount"
        },
        "path": {
          "description": "A unix-formatted filesystem path with ` + "`" + `/` + "`" + ` relative to the respective base.",
          "type": "string"
        },
        "recursive": {
          "description": "perform a recursive bind mount",
          "type": "boolean",
          "default": false
        },
        "ro": {
          "description": "mount read-only",
          "type": "boolean",
          "default": false
        }
      }
    },
    "mount_nfs": {
      "description": "` + "`" + `mount_nfs` + "`" + ` describes an NFS mount.\n",
      "type": "object",
      "required": [
        "host",
        "path"
      ],
      "properties": {
        "host": {
          "description": "IP or hostname for remote NFS mount",
          "type": "string"
        },
        "options": {
          "description": "Options as specified in nfs(5).  General mount options won't work here.\naddr= and clientaddr= will be filled out automatically based on host.\nvers= will be filled by version\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "path": {
          "description": "The remote path for the NFS mount",
          "type": "string"
        },
        "ro": {
          "description": "mount read-only",
          "type": "boolean",
          "default": false
        },
        "version": {
          "description": "NFS version",
          "type": "string",
          "default": "4.2"
        }
      }
    },
    "mount_overlay": {
      "description": "` + "`" + `mount_overlay` + "`" + ` describes an Overlayfs mount.  All mount points must be RBD ID's.\nAt very least, ` + "`" + `lower` + "`" + ` must be specified.  If ` + "`" + `upper` + "`" + ` length is zero, no ` + "`" + `upper` + "`" + `\nmounts will be used.  ` + "`" + `workdir` + "`" + ` will be assigned automatically.\n\nIf the mounts specified in ` + "`" + `lower` + "`" + ` are specifications and not ID references, they\nwill be recursively mounted/attached.\n\nOverlay mounts are identified by their uppermost ` + "`" + `lower` + "`" + ` ID.\n",
      "type": "object",
      "required": [
        "lower"
      ],
      "properties": {
        "lower": {
          "description": "This is an array of mount specifications to be used (in order) as lower mounts for the overlay.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/mount"
          }
        },
        "upperdir": {
          "description": "currently, upperdir is always a directory in mountDir",
          "type": "string",
          "readOnly": true
        },
        "workdir": {
          "type": "string",
          "readOnly": true
        }
      }
    },
    "name": {
      "description": "A name is a unique, user-provided identifier for an object.\n\nA name must consist of numbers, letters, and the symbols in the set { ` + "`" + `.` + "`" + `, ` + "`" + `-` + "`" + `, ` + "`" + `_` + "`" + `}.\n",
      "type": "string",
      "pattern": "^[A-Za-z0-1.\\-_]*$"
    },
    "rbd_options": {
      "type": "object",
      "properties": {
        "abort_on_full": {
          "type": "boolean"
        },
        "alloc_size": {
          "type": "integer"
        },
        "ceph_requires_signatures": {
          "type": "boolean"
        },
        "cephx_sign_messages": {
          "type": "boolean"
        },
        "crc": {
          "type": "boolean"
        },
        "exclusive": {
          "type": "boolean"
        },
        "force": {
          "type": "boolean"
        },
        "fsid": {
          "type": "string"
        },
        "ip": {
          "type": "string",
          "format": "ipv4",
          "pattern": "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$"
        },
        "lock_on_read": {
          "type": "boolean"
        },
        "lock_timeout": {
          "type": "integer",
          "format": "int64"
        },
        "mount_timeout": {
          "type": "integer"
        },
        "name": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "noceph_requires_signatures": {
          "type": "boolean"
        },
        "nocephx_sign_messages": {
          "type": "boolean"
        },
        "nocrc": {
          "type": "boolean"
        },
        "noshare": {
          "type": "boolean"
        },
        "notcp_nodelay": {
          "type": "boolean"
        },
        "notrim": {
          "type": "boolean"
        },
        "osd_idle_ttl": {
          "type": "integer"
        },
        "osdkeepalive": {
          "type": "integer"
        },
        "queue_depth": {
          "type": "integer"
        },
        "ro": {
          "type": "boolean"
        },
        "rw": {
          "type": "boolean"
        },
        "secret": {
          "type": "string"
        },
        "share": {
          "type": "boolean"
        },
        "tcp_nodelay": {
          "type": "boolean"
        }
      }
    }
  }
}`))
}
